function patchCheckEmscriptenSignalHelpers() {
  const _orig_Py_CheckEmscriptenSignals_Helper =
    _Py_CheckEmscriptenSignals_Helper;
  const suspending = new WebAssembly.Function(
    { parameters: ["externref"], results: [] },
    () => sleep(0),
    { suspending: "first" },
  );
  const bytes = [
    0, 97, 115, 109, 1, 0, 0, 0, 1, 9, 2, 96, 0, 1, 127, 96, 1, 111, 0, 2, 27,
    4, 1, 101, 1, 115, 3, 111, 1, 1, 101, 1, 99, 3, 127, 1, 1, 101, 1, 105, 0,
    0, 1, 101, 1, 114, 0, 1, 3, 2, 1, 0, 7, 5, 1, 1, 111, 0, 2, 10, 23, 1, 21,
    1, 1, 111, 35, 1, 4, 64, 35, 0, 34, 0, 16, 1, 32, 0, 36, 0, 11, 16, 0, 11,
  ];
  const module = new WebAssembly.Module(new Uint8Array(bytes));
  const instance = new WebAssembly.Instance(module, {
    e: {
      s: Module.suspenderGlobal,
      r: suspending,
      i: _orig_Py_CheckEmscriptenSignals_Helper,
      c: Module.validSuspender,
    },
  });
  _Py_CheckEmscriptenSignals_Helper = instance.exports.o;
}

/**
 * This is a list of continuations that have some of their state in the actual
 * argument stack. restore() may overwrite some of them (or just move the stack
 * pointer above them), and so it will have to save them into UInt8Arrays.
 * @private
 */
const stackStates = [];

/**
 * A class to help us keep track of the argument stack data for our individual
 * continuations. The suspender automatically and opaquely handles the call
 * stack for us, but the argument stack is an abstraction generated by the
 * compiler and we have to manage it ourselves.
 * @private
 */
class StackState {
  constructor() {
    /** current stack pointer */
    this.start = Module.___stack_pointer.value;
    /**
     * The value the stack pointer had when we entered Python. This is how far
     * up the stack the current continuation cares about. This was recorded just
     * before we entered Python in callPyObjectKwargsSuspending.
     */
    this.stop = Module.stackStop;
    /**
     * Where we store the data if it gets ejected from the actual argument
     * stack.
     */
    this._copy = new Uint8Array(0);
  }

  /**
   * Restore the argument stack in preparation to run the continuation.
   * @returns How much data we copied. (Only for debugging purposes.)
   */
  restore() {
    let total = 0;
    // Search up the stack for things that need to be ejected in their entirety
    // and save them
    while (
      stackStates.length > 0 &&
      stackStates[stackStates.length - 1].stop < this.stop
    ) {
      total += stackStates.pop()._save();
    }
    // Part of one more object may need to be ejected.
    const last = stackStates[stackStates.length - 1];
    if (last && last !== this) {
      total += last._save_up_to(this.stop);
    }
    // If we just saved all of the last stackState it needs to be removed.
    // Alternatively, the current StackState may be on the stackStates list.
    // Technically it would make sense to leave it there, but we will add it
    // back if we suspend again and if we exit normally it gets removed from the
    // stack.
    if (last && last.stop === this.stop) {
      stackStates.pop();
    }
    if (this._copy.length !== 0) {
      // Now that we've saved everything that might be in our way we can restore
      // the current stack data if need be.
      Module.HEAP8.set(this._copy, this.start);
      total += this._copy.length;
      this._copy = new Uint8Array(0);
    }
    // Restore stack pointers
    Module.stackStop = this.stop;
    Module.___stack_pointer.value = this.start;
    return total;
  }

  /**
   * Copy part of a stack frame into the _copy Uint8Array
   * @param {number} stop What part of the frame to copy
   * @returns How much data we copied (for debugging only)
   */
  _save_up_to(stop) {
    let sz1 = this._copy.length;
    let sz2 = stop - this.start;
    if (sz2 <= sz1) {
      return 0;
    }
    const new_segment = HEAP8.subarray(this.start + sz1, this.start + sz2);
    const c = new Uint8Array(sz2);
    c.set(this._copy);
    c.set(new_segment, sz1);
    this._copy = c;
    return sz2;
  }

  /**
   * Copy all of a stack frame into its _copy Uint8Array
   * @returns How much data we copied (for debugging only)
   */
  _save() {
    return this._save_up_to(this.stop);
  }
}

/**
 * Record the current Python thread state and the wasm argument stack state.
 * This is called by the hiwire_syncify wasm module just prior to suspending the
 * thread. `hiwire_syncify` uses `externref` for the return value so we don't
 * need to wrap this in a hiwire ID.
 */
function save_state() {
  const stackState = new StackState();
  stackStates.push(stackState);
  return {
    stackState,
    threadState: Module._captureThreadState(),
    suspender: Module.suspenderGlobal.value,
  };
}

/**
 * Record the current Python thread state and the wasm argument stack state.
 * This is called by the hiwire_syncify wasm module just prior to suspending the
 * thread. `hiwire_syncify` uses `externref` for the return value so we don't
 * need to wrap this in a hiwire ID.
 */
function restore_state(state) {
  state.stackState.restore();
  Module._restoreThreadState(state.threadState);
  Module.suspenderGlobal.value = state.suspender;
  Module.validSuspender.value = true;
}

function patchHiwireSyncify() {
  const suspending_f = new WebAssembly.Function(
    { parameters: ["externref", "i32"], results: ["i32"] },
    async (x) => {
      return Hiwire.new_value(await Hiwire.get_value(x));
    },
    { suspending: "first" },
  );

  const bytes = [
    0, 97, 115, 109, 1, 0, 0, 0, 1, 20, 4, 96, 2, 111, 127, 1, 127, 96, 0, 1,
    111, 96, 1, 111, 0, 96, 1, 127, 1, 127, 2, 42, 5, 1, 101, 1, 115, 3, 111, 1,
    1, 101, 1, 99, 3, 127, 1, 1, 101, 1, 105, 0, 0, 1, 101, 4, 115, 97, 118,
    101, 0, 1, 1, 101, 7, 114, 101, 115, 116, 111, 114, 101, 0, 2, 3, 2, 1, 3,
    7, 5, 1, 1, 111, 0, 3, 10, 29, 1, 27, 1, 1, 111, 35, 1, 69, 4, 64, 65, 0,
    15, 11, 16, 1, 33, 1, 35, 0, 32, 0, 16, 0, 32, 1, 16, 2, 11,
  ];
  const module = new WebAssembly.Module(new Uint8Array(bytes));

  const instance = new WebAssembly.Instance(module, {
    e: {
      s: Module.suspenderGlobal,
      i: suspending_f,
      c: Module.validSuspender,
      save: save_state,
      restore: restore_state,
    },
  });
  _hiwire_syncify = instance.exports.o;
}

Module.wrapApply = function (apply) {
  const bytes = [
    0, 97, 115, 109, 1, 0, 0, 0, 1, 20, 2, 96, 5, 127, 127, 127, 127, 127, 1,
    127, 96, 6, 111, 127, 127, 127, 127, 127, 1, 127, 2, 14, 2, 1, 101, 1, 115,
    3, 111, 1, 1, 101, 1, 105, 0, 0, 3, 2, 1, 1, 7, 5, 1, 1, 111, 0, 1, 10, 20,
    1, 18, 0, 32, 0, 36, 0, 32, 1, 32, 2, 32, 3, 32, 4, 32, 5, 16, 0, 11,
  ];
  var module = new WebAssembly.Module(new Uint8Array(bytes));
  var instance = new WebAssembly.Instance(module, {
    e: {
      s: Module.suspenderGlobal,
      i: apply,
    },
  });
  return new WebAssembly.Function(
    { parameters: ["i32", "i32", "i32", "i32", "i32"], results: ["externref"] },
    instance.exports.o,
    { promising: "first" },
  );
};

Module.initSuspenders = function () {
  try {
    // Feature detect externref. Also need it for wrapApply to work.
    Module.suspenderGlobal = new WebAssembly.Global(
      { value: "externref", mutable: true },
      null,
    );
    // Feature detect WebAssembly.Function and JS Promise integration
    Module.wrapApply(
      new WebAssembly.Function(
        { parameters: ["i32", "i32", "i32", "i32", "i32"], results: ["i32"] },
        () => {},
      ),
    );
  } catch (e) {
    // Browser doesn't support externref. This implies it also doesn't support
    // stack switching so we won't need a suspender.
    Module.validSuspender = { value: 0 };
    Module.suspendersAvailable = false;
    return;
  }
  Module.validSuspender = new WebAssembly.Global(
    { value: "i32", mutable: true },
    0,
  );
  // patchCheckEmscriptenSignalHelpers();
  patchHiwireSyncify();
  Module.suspendersAvailable = true;
};
