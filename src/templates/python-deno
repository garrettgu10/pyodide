#!/bin/bash
":"; /* << "EOF"
This file is a bash/node polyglot.

We have to use a bit of bash code to set up the deno permissions / command line args.

We could use a bash script in a separate file to determine the flags needed,
but virtualenv looks up the current file and uses it directly. So if we make
python.sh and have it invoke python.js, then the virtualenv will invoke python.js
directly without the setup.

Keeping the bash script and the JavaScript in the same file makes sure that even
inside the virtualenv the proper shell code is executed.
*/

/*
EOF

VENV_DIR="$(dirname $0)"
# Resolving the python symlink gives us the Pyodide dist directory.
PYODIDE_DIST_DIR="$(dirname "$(readlink -f "$0")")"

# Make an import map to resolve relative imports relative to the Pyodide dist
# directory instead of relative to the virtual environment directory.
cat << END > $VENV_DIR/importmap.json
{
    "imports" : { "./" : "$PYODIDE_DIST_DIR/" }
}
END

exec deno run \
    --import-map=$VENV_DIR/importmap.json \
    --allow-read \
    --allow-env \
    $DENO_OPTIONS \
    $0  "$@"
*/

import {
  hrtime,
  stdin,
  stdout,
  stderr,
  env,
  exit,
  cwd,
  argv,
  platform,
  versions,
} from "node:process";
import { createRequire } from "node:module";
import * as fs from "node:fs";

import { loadPyodide } from "./pyodide.mjs";

globalThis.require = createRequire(import.meta.url);
globalThis.__dirname = new URL(".", import.meta.url).pathname;

globalThis.process = {
  release: { name: "node" },
  versions,
  exit,
  env,
  cwd,
  argv,
  platform,
  hrtime,
  stdin,
  stdout,
  stderr,
};

/**
 * Determine which native top level directories to mount into the Emscripten
 * file system.
 *
 * This is a bit brittle, if the machine has a top level directory with certain
 * names it is possible this could break. The most surprising one here is tmp, I
 * am not sure why but if we link tmp then the process silently fails.
 */
function rootDirsToMount() {
  const skipDirs = ["dev", "lib", "proc", "tmp"];
  return fs
    .readdirSync("/")
    .filter((dir) => !skipDirs.includes(dir))
    .map((dir) => "/" + dir);
}

function dirsToMount() {
  const extra_mounts = process.env["_PYODIDE_EXTRA_MOUNTS"] || "";
  return rootDirsToMount().concat(extra_mounts.split(":").filter((s) => s));
}

async function loadPyodideHandleEarlyExit() {
  let args = process.argv.slice(2);
  try {
    return await loadPyodide({
      args,
      fullStdLib: false,
      _node_mounts: dirsToMount(),
      homedir: process.cwd(),
    });
  } catch (e) {
    if (e.constructor.name !== "ExitStatus") {
      throw e;
    }
    // If the user passed `--help`, `--version`, or a set of command line
    // arguments that is invalid in some way, we will exit here.
    process.exit(e.status);
  }
}

async function main() {
  let py = await loadPyodideHandleEarlyExit();
  py._api.on_fatal = () => process.exit(1);
  py.setStdout();
  py.setStderr();
  let sideGlobals = py.runPython("{}");
  function handleExit(code) {
    if (code === undefined) {
      code = 0;
    }
    if (py._module._Py_FinalizeEx() < 0) {
      code = 120;
    }
    // It's important to call `process.exit` immediately after
    // `_Py_FinalizeEx` because otherwise any asynchronous tasks still
    // scheduled will wasm segfault.
    process.exit(code);
  }
  sideGlobals.set("handleExit", handleExit);

  py.runPython(
    `
        from pyodide._package_loader import SITE_PACKAGES, should_load_dynlib
        from pyodide.ffi import to_js
        import re
        dynlibs_to_load = to_js([
            str(path) for path in SITE_PACKAGES.glob("**/*.so*")
            if should_load_dynlib(path)
        ])
        `,
    { globals: sideGlobals }
  );
  const dynlibs = sideGlobals.get("dynlibs_to_load");
  for (const dynlib of dynlibs) {
    try {
      await py._module.API.loadDynlib(dynlib);
    } catch (e) {
      console.error("Failed to load lib ", dynlib);
      console.error(e);
    }
  }

  py.runPython(
    `
        import asyncio
        # Keep the event loop alive until all tasks are finished, or SystemExit or
        # KeyboardInterupt is raised.
        loop = asyncio.get_event_loop()
        # Make sure we don't run _no_in_progress_handler before we finish _run_main.
        loop._in_progress += 1
        loop._no_in_progress_handler = handleExit
        loop._system_exit_handler = handleExit
        loop._keyboard_interrupt_handler = lambda: handleExit(130)

        # Make shutil.get_terminal_size tell the terminal size accurately.
        import shutil
        from js.process import stdout
        import os
        def get_terminal_size(fallback=(80, 24)):
            columns = getattr(stdout, "columns", None)
            rows = getattr(stdout, "rows", None)
            if columns is None:
                columns = fallback[0]
            if rows is None:
                rows = fallback[1]
            return os.terminal_size((columns, rows))
        shutil.get_terminal_size = get_terminal_size
        `,
    { globals: sideGlobals }
  );

  let errcode;
  try {
    errcode = py._module._run_main();
  } catch (e) {
    // If someone called exit, just exit with the right return code.
    if (e.constructor.name === "ExitStatus") {
      process.exit(e.status);
    }
    // Otherwise if there is some sort of error, include the Python
    // tracebook in addition to the JavaScript traceback
    py._module._dump_traceback();
    throw e;
  }
  if (errcode) {
    process.exit(errcode);
  }
  py.runPython("loop._decrement_in_progress()", { globals: sideGlobals });
}
main().catch((e) => {
  console.error(e);
  process.exit(1);
});
